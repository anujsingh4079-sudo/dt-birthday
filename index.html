<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flappy Bird Phone (Game Over Image)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #70c5ce;
      font-family: Arial, sans-serif;
      user-select: none;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
    }
    #gameCanvas {
      background: #4ec0ca;
      display: block;
      border: 2px solid #333;
      touch-action: none;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 28px;
      text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
      pointer-events: none;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 26px;
      text-align: center;
      text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
      pointer-events: none;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="score">0</div>
    <div id="message">Tap or press space to start</div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const messageEl = document.getElementById('message');

    // SOUNDS
    const flapSound = new Audio('flap.mp3');
    const hitSound = new Audio('hit.mp3');
    flapSound.preload = 'auto';
    hitSound.preload = 'auto';

    // GAME OVER IMAGE
    const gameOverImg = new Image();
    gameOverImg.src = 'gameover.png';

    // MULTIPLE PIPE IMAGES
    const pipeImages = {
      short: new Image(),
      medium: new Image(),
      long: new Image()
    };
    pipeImages.short.src = 'pipe-short.png';
    pipeImages.medium.src = 'pipe-medium.png';
    pipeImages.long.src = 'pipe-long.png';

    // Responsive canvas
    function resizeCanvas() {
      const ratio = 2 / 3;
      let w = Math.min(window.innerWidth * 1.2, 600);
      let h = w / ratio;
      if (h > window.innerHeight * 1.2) {
        h = window.innerHeight * 1.2;
        w = h * ratio;
      }
      canvas.width = w;
      canvas.height = h;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const birdImg = new Image();
    birdImg.src = 'bird.png';

    const GRAVITY = 0.4;
    const JUMP = -7;
    const PIPE_GAP = 280;
    const PIPE_SPEED = 2;
    const PIPE_INTERVAL = 2500;

    let bird = { x: 80, y: 0, w: 34, h: 24, vy: 0 };
    let pipes = [];
    let lastPipeTime = 0;
    let score = 0;
    let running = false;
    let gameOver = false;

    function resetGame() {
      resizeCanvas();
      bird.x = canvas.width * 0.25;
      bird.y = canvas.height / 2;
      bird.vy = 0;
      bird.h = canvas.height * 0.075;
      bird.w = bird.h * (34 / 24);

      pipes = [];
      lastPipeTime = 0;
      score = 0;
      scoreEl.textContent = score;
      running = false;
      gameOver = false;
      messageEl.textContent = 'Tap or press space to start';
    }

    function spawnPipe() {
      const minTopHeight = canvas.height * 0.08;
      const maxTopHeight = canvas.height - PIPE_GAP - canvas.height * 0.08;
      const topHeight = Math.floor(
        Math.random() * (maxTopHeight - minTopHeight) + minTopHeight
      );

      const pipeWidth = canvas.width * 0.16;

      const getPipeType = (height) => {
        if (height < canvas.height * 0.25) return 'short';
        if (height < canvas.height * 0.4) return 'medium';
        return 'long';
      };

      pipes.push({
        x: canvas.width,
        y: 0,
        w: pipeWidth,
        h: topHeight,
        type: getPipeType(topHeight),
        passed: false
      });

      pipes.push({
        x: canvas.width,
        y: topHeight + PIPE_GAP,
        w: pipeWidth,
        h: canvas.height - topHeight - PIPE_GAP,
        type: getPipeType(canvas.height - topHeight - PIPE_GAP),
        passed: false
      });
    }

    function update(delta) {
      if (!running) return;

      bird.vy += GRAVITY;
      bird.y += bird.vy;

      if (bird.y + bird.h > canvas.height) {
        bird.y = canvas.height - bird.h;
        endGame();
      }
      if (bird.y < 0) {
        bird.y = 0;
        bird.vy = 0;
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        const p = pipes[i];
        p.x -= PIPE_SPEED;

        const isTopPipe = p.y === 0;
        if (isTopPipe && !p.passed && p.x + p.w < bird.x) {
          p.passed = true;
          score++;
          scoreEl.textContent = score;
        }

        if (p.x + p.w < 0) {
          pipes.splice(i, 1);
        }
      }

      for (const p of pipes) {
        if (
          bird.x < p.x + p.w &&
          bird.x + bird.w > p.x &&
          bird.y < p.y + p.h &&
          bird.y + bird.h > p.y
        ) {
          hitSound.currentTime = 0;
          hitSound.play().catch(() => {});
          endGame();
          break;
        }
      }

      if (performance.now() - lastPipeTime > PIPE_INTERVAL) {
        spawnPipe();
        lastPipeTime = performance.now();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      pipes.forEach(p => {
        const img = pipeImages[p.type];
        if (img.complete && img.naturalWidth !== 0) {
          ctx.save();
          if (p.y === 0) {
            ctx.translate(p.x + p.w / 2, p.y + p.h);
            ctx.rotate(Math.PI);
            ctx.drawImage(img, -p.w / 2, 0, p.w, p.h);
          } else {
            ctx.drawImage(img, p.x, p.y, p.w, p.h);
          }
          ctx.restore();
        } else {
          ctx.fillStyle = '#1abc9c';
          ctx.fillRect(p.x, p.y, p.w, p.h);
        }
      });

      if (birdImg.complete && birdImg.naturalWidth !== 0) {
        ctx.drawImage(birdImg, bird.x, bird.y, bird.w, bird.h);
      } else {
        ctx.fillStyle = 'yellow';
        ctx.fillRect(bird.x, bird.y, bird.w, bird.h);
      }

      // GAME OVER IMAGE (appears when gameOver = true)
      if (gameOver && gameOverImg.complete && gameOverImg.naturalWidth !== 0) {
        ctx.globalAlpha = 1.0; // Full opacity (zero transparency)
        ctx.drawImage(gameOverImg, 
          canvas.width / 2 - 150, 
          canvas.height / 2 - 100, 
          300, 200  // Scale to fit screen center
        );
        ctx.globalAlpha = 1.0; // Reset transparency
      }
    }

    let lastTime = 0;
    function loop(timestamp) {
      const delta = timestamp - lastTime;
      lastTime = timestamp;
      update(delta);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function flap() {
      flapSound.currentTime = 0;
      flapSound.play().catch(() => {});

      if (!running && !gameOver) {
        running = true;
        messageEl.textContent = '';
        lastPipeTime = performance.now();
        spawnPipe();
      }
      if (!gameOver) {
        bird.vy = JUMP;
      }
    }

    function endGame() {
      if (gameOver) return;
      running = false;
      gameOver = true;
      // Show game over image + text
      messageEl.textContent = '';
    }

    canvas.addEventListener('mousedown', () => {
      if (gameOver) resetGame();
      else flap();
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameOver) resetGame();
      else flap();
    }, { passive: false });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameOver) resetGame();
        else flap();
      }
    });

    resetGame();
  </script>
</body>
</html>

